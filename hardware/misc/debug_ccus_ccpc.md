Trying to get the damn COM event to trigger the loading of the OCRx and CCx[N]E registers into the shadow registers

The STM32G4xx manual suggests under its Hall sensor interfacing documentation to use the COM event along with some control bits in CR2 (CCUS and CCPC) to preload the values for the control registers in one frame of the hall ticks and have them loaded in in the next, all at the same time, synchronous with the Hall sensor itself. I wanted to start ticking on the hall sensor inputs via XOR which was separately motivated by wanting higher-resolution velocity data via its input-compare functionality, and pushing the motor tick onto that handler seemed like a good idea. I was struggling initially with getting the COM event itself to fire; the manual suggested putting the ticking code in the CCR2 handler anyways. However, I started to encounter some weird behavior.

The most persistent and actually the first problem I ran into at all was that the motor would tick veeery briefly at the edge of each hall sensor, before going quiet. This was very bizzare, it was triggering the COM interrupt even. The first major suspect was the CCR2 output to TRGO on TIM4, the "interfacing timer" that had the XOR on it. It was in PWM mode 2, which meant that it went low for the split second that CNT was below CCR2, then high for the rest of the timer period, _then low again when the one-shot expired and CNT was forced back to 0_. I knew that it had to be a posedge... but something in me suspected that maybe it was firing for the duration of that timer period (which at the time was 32MHz/32/65536 = 65ms, so pretty short), so I tried:

1. Increasing the timer prescaler. The blip didn't get longer unfortunately.
2. Changing the PWM timer mode. The wording in the manual said that TIM4 needed to send a "pulse" along TRGO, so I thought that maybe because the pulse from TIM4 as it was, spanning the whole period of the timer (65ms) was longer than the period of TIM1 (32MHz/8/256 = 64us), and maybe the update event was preloading zeroes back onto the CCR. Note that the combination of shadow registers and the trigger events were very annoyingly both invisible to debugging. Also note that the diagrams for the counter loading/capturing in the manual only show the update event as enabled by the preload enable and output mode in CCMR (see page 1112). Nothing about COM + CCUS + CCPC.

  I misread the 0b0001 option for OC2M as being a pulse only on the clock cycle where CNT == CCR2, when in fact it latched the output high. That meant I was only getting the single update at the beginning from the first hall sensor which added to my confusion. But then the moment of lucidity. I noticed that while this latching was happening, only one of the phases seemed to be energizing, and _it depended on the motor phase_. When I made all three CCRx non-zero, then it was constantly energized. When I realized my mistake with the PWM compare mode (after banging my head on why it was only energizing when I had added CCRx declarations before starting the TIM4 base) it all came together. **The enable bits were being set synchronously.** That's why the blip width was independent of the timer prescaler: it was the length between the CCR2 interrupt on TIM4 sending the TRGO to TIM1 and the motor_tick interrupt callback reaching the point where it set the compare enables.
  
Some other miscellaneous behaviors that made my night more fun:

1. Triggering the events don't actually do some things: e.g. triggering the CCR2 event on TIM4 didn't send the TRGO; triggering TRIG on TIM4 also doesn't do the trigger behavior for the one-shot counter. IT just sets the interrupt flags and triggers interrupt handlers and DMA. It's not exactly like generating those events.
2. Thanks to the latching of the 0b0001 option, I thought that the COM interrupt only fired when the registers changed. This kind of comparison with the existing value was also related with the fact that only one coil was energized: possibly it was forcing an equality with the initial set value of the register. Of course that was all wrong.
3. The COM interrupt doesn't work if both CCUS and CCPC aren't set together. I wanted to avoid them and still get the interrupt to verify the trigger was firing and hopefully also get the coils energized more permanently. Kind of makes sense, kind of a pain though. (Possibly weaker than that, for sure the interrupt doesn't fire if CCPC isn't set. This isn't noted in the manual).

Still... it's weird. I haven't actually 100% verified this yet in the original setup. I'm weirded out by the fact that I didn't catch this despite stopping in the `motor_tick` handler before the enables were set, since it's the last thing. I'm pretty sure it was still blipping despite the CCER being consistent...

Ah. It does work. My guess is that initially I was confused by the triggering: I thought that the event triggering would be enough to get the first pulse in, so when it didn't work I didn't investigate further. Clearly now I see that it fires properly before getting clobbered by the CCR set.

Now. The question. Is WHY?! Is this a mistake in the documentation? Clearly it says that CCxE and CCxNE are buffered alongside CCR... 

Ohhh shiittttttt it was the OPPOSITE! CCR is being set synchronously, while CCx[N]E is set on the next cycle. Sigh... But then why was my motor spinning? Ah. I had offset it by the other amount. So... that should've been it? Man. How did I misread that? I thought OCxM was the compare register thanks to Arduino's training me of OCxRA/B... DAMMIT. It all makes sense. When I was pausing after setting all the registers to 0, it was really all zeroes. And it was out of phase with the CCxE/NE. God.

I guess this makes sense, for any sinusoidal business/doing other analog things inside the the hall sensor period, we want to keep the CCR registers synchronous. Just... dammit man.